<!-- build time:Thu Jan 30 2025 15:25:59 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Blog" href="https://memoryoffish.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Blog" href="https://memoryoffish.github.io/atom.xml"><link rel="alternate" type="application/json" title="Blog" href="https://memoryoffish.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔者是菜鸟，上课不记笔记，因而只有补天笔记了"><link rel="canonical" href="https://memoryoffish.github.io/2025/01/25/less/x86/x86/"><title>x86汇编笔记 - 汇编 - 通识课 | memory of fish = Blog</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">x86汇编笔记</h1><div class="meta"><span class="item" title="创建时间：2025-01-25 17:15:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-01-25T17:15:00+08:00">2025-01-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">memory of fish</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://image.baidu.com/search/down?url=https://tva3.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://image.baidu.com/search/down?url=https://tva3.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://image.baidu.com/search/down?url=https://tva3.sinaimg.cn/large/6833939bly1giph47e9vtj20zk0m8x6l.jpg"></li><li class="item" data-background-image="https://image.baidu.com/search/down?url=https://tva3.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://image.baidu.com/search/down?url=https://tva3.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li><li class="item" data-background-image="https://image.baidu.com/search/down?url=https://tva3.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/less/" itemprop="item" rel="index" title="分类于 通识课"><span itemprop="name">通识课</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/less/x86/" itemprop="item" rel="index" title="分类于 汇编"><span itemprop="name">汇编</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://memoryoffish.github.io/2025/01/25/less/x86/x86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="小丑鱼"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Blog"></span><div class="body md" itemprop="articleBody"><h1 id="期末复习"><a class="anchor" href="#期末复习">#</a> 期末复习</h1><ol><li>dos 程序里有 edit main.asm 这条 edit 指令按 F3 和 E 退出</li></ol><h2 id="数制"><a class="anchor" href="#数制">#</a> 数制</h2><p>十六进制 h 或 H 为后缀 最高位是字母要加前缀 0<br>八进制 Q 或 q 为后缀<br>二进制 B 或 b 为后缀</p><h3 id="数的位"><a class="anchor" href="#数的位">#</a> 数的位</h3><p>bit (1 位)、byte（8 位）、word（16 位）、dword（32 位）、qword（64 位）、tbyte（80 位）共 6 种<br>采用小数排序，低位在后，高位在前对应的有高字节低字节高字低字的说法，在 data 段表示如下：<br>dw：word 相当于 short int 或 unsigned short int<br>dd：dword 相当于 long int 或 unsigned long int 或 float 类型<br>db: byte<br>dq：qword 相当于 long long 或 double<br>dt：tbyte long double<br>这些都可以表示数组，关键看后面数量<br>注意 <code>a db &quot;abc&quot;</code> 是 'a','b','c' 要后面自己补 '\0'</p><h3 id="符号数"><a class="anchor" href="#符号数">#</a> 符号数</h3><p>首位为负的其他为正的</p><h3 id="零扩充与符号扩充"><a class="anchor" href="#零扩充与符号扩充">#</a> 零扩充与符号扩充</h3><p>mov，add 这些要求两个操作数等宽，零扩充指非符号数扩 0，有符号数阔符号位陈伟符号扩充</p><h3 id="字符表示"><a class="anchor" href="#字符表示">#</a> 字符表示</h3><p>ASCII 定义 256 个字符，标准 ASCII 仅需要后七位，128 个字符。0 到 1Fh 以及 7Fh 等 33 个不可打印<br>大小写字母距离 20h，也就是十进制的 32</p><h3 id="二进制数据计算"><a class="anchor" href="#二进制数据计算">#</a> 二进制数据计算</h3><p>mul 是非符号乘法<br>imul 是符号数<br>fadd 是小数加法 <code>fadd st(0),st(1)</code><br>其他类推</p><table><thead><tr><th>指令</th><th>含义</th><th>用法</th></tr></thead><tbody><tr><td>shl</td><td>逻辑左移（shift logic left）</td><td>shl ax,1 或 shl ax,cl (8086 中) 开头有.386 则可以把 1 改成任意 8 位常数 其实就是 dest&lt;&lt;=count &amp;1Fh 这个 1Fh 是 31 的意思，可以操作 c 这种数据变量</td></tr><tr><td>shr</td><td>逻辑右移</td><td>最高位补 0，末尾进 CF</td></tr><tr><td>sar</td><td>算术右移</td><td>首位不变，然后首位放入第二位，之后往后退，末位进 CF</td></tr><tr><td>sal</td><td>算术左移</td><td>与逻辑左移是一样的，</td></tr><tr><td>rol</td><td>循环左移</td><td>首位进入 CF，首位变成最后一位，依次往前</td></tr><tr><td>rcl</td><td>带进位循环左移</td><td>首位进入 CF，CF 成为最后一位</td></tr></tbody></table><h2 id="cpu-内存和端口"><a class="anchor" href="#cpu-内存和端口">#</a> CPU、内存和端口</h2><p>由三部分组成：算术逻辑单元 (ALU)、控制单元（CU)、寄存器 (register)。CU 作用为取指令、解释指令、执行指令，只有寄存器可以编程控制<br>内存存储指令和变量执行 link 时，dos 会打开并读取 link.exe 载入内存，然后 link 在内存中运行。</p><h3 id="内存"><a class="anchor" href="#内存">#</a> 内存</h3><p>dos 系统运行在 CPU 的实模式（real mode）下，可访问地址 <code>[00000h,0FFFFFh]</code> 这个 1MB 内存空间。<br>我们使用段地址：偏移地址这种组合形式来简介访问物理地址。<br>偏移地址表示某个变量或标号与段首距离，段地址是段首地址的高 16 位。<br>段是符合以下两要求的内存：</p><ul><li>长度为 10000h 即 64KB</li><li>内存块 20 位首地址必须为 0<br><code>[12340h,223Fh]</code> 可构成一个段，计算大小头尾都要计算<br>12341h 可表示为 1234h:0001h</li></ul><h3 id="逻辑地址"><a class="anchor" href="#逻辑地址">#</a> 逻辑地址</h3><p>8086 中，逻辑地址就是上述写法，可以用 ds: <code>[5678h]</code> 的写法但是段地址不能用常数<br>在源程序中，用 offset 变量名或标号名来引用变量或标号的偏移地址如 <code>offset a</code><br>, 段地址则用 seg a 或 seg s 或者段名 data 来引用 data 段的段地址。</p><h4 id="直接寻址和间接寻址"><a class="anchor" href="#直接寻址和间接寻址">#</a> 直接寻址和间接寻址</h4><p>用常数表示偏移地址时为直接寻址，包含寄存器位间接寻址，如 <code>mov ax,ds:[bx+2]</code><br>直接寻址一般为段寄存器:var <code>[常数]</code> 或段寄存器: <code>[常数+var]</code> 因为这个变量其实编译后就变成了对应偏移地址常量了<br>间接寻址有四种：</p><ul><li><code>[寄存器]</code> : <code>[bp]、[bx]、[si]、[di]</code></li><li><code>[寄存器+常数]</code></li><li><code>[寄存器+寄存器]</code></li><li><code>[寄存器+寄存器+常数]</code><br>注意到其实寄存器只能用 bp 和 bx 和 si 和 di 这四种 bx 其实就是个乱入的，后续发现只有三个塞进来的，<br><strong>当然重要是当两个寄存器相加时，其中一个必须从 bp、bx 中选，另一个从 si、di 中选__这个常数可以是 0</strong>，然后其实加入变量也是可以的，因为变量其实就是常数如 var <code>[bx]</code><br>80836 的间接寻址比较普遍点，一般形式为 <code>[寄存器+寄存器*N+常数]</code> , 其中 N 是集合 {1,2,4,8} 内的一个元素，寄存器从以下寻找：<br>EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI, 其实就是 bx 带家人来了，然后多了个 ESP</li></ul><h3 id="小端规则"><a class="anchor" href="#小端规则">#</a> 小端规则</h3><p>CPU 会先将低 8 位写在前高 8 位写在后<br>框架如下，存储 1234h</p><p>| 地址 | 值 |<br>|---|---|<br>|2000 |34h |<br>|2001 |12h |</p><h3 id="缺省段址和段覆盖"><a class="anchor" href="#缺省段址和段覆盖">#</a> 缺省段址和段覆盖</h3><h4 id="缺省段址"><a class="anchor" href="#缺省段址">#</a> 缺省段址</h4><p>省略段地址规则如下:</p><ul><li>直接寻址为 DS</li><li>间接寻址包含 BP 的话，就是 SS （栈嘛)</li><li>间接寻址不含 BP，就是 DS</li></ul><h4 id="段覆盖"><a class="anchor" href="#段覆盖">#</a> 段覆盖</h4><p>其实就是加了段前缀 ss，cs，es，ds 这四个就是所有段寄存器</p><p>小小总结下：就是四个段寄存器和四个偏移地址寄存器的故事</p><h3 id="1m内存空间划分和显卡映射"><a class="anchor" href="#1m内存空间划分和显卡映射">#</a> 1M 内存空间划分和显卡映射</h3><p>16 位 CPU 只能访问 0000:0000 到 F000:FFFF 的 1M 内存空间，内存空间划分如下:<br># 难记得很</p><table><thead><tr><th>地址范围</th><th>用途</th><th>大小</th></tr></thead><tbody><tr><td><code>[0000:0000,9000:FFFF]</code></td><td>操作系统和用户程序</td><td>A0000h 嘛</td></tr><tr><td><code>[A000:0000,A000:FFFF]</code></td><td>映射显卡内存</td><td>10000h</td></tr><tr><td><code>[B000:0000,B000:7FFF]</code></td><td>映射显卡内存</td><td>8000h</td></tr><tr><td><code>[B800:0000,B800:7FFF]</code></td><td>映射显卡内存</td><td>8000h</td></tr><tr><td><code>[C000:0000,F000:FFFF]</code></td><td>映射 ROM</td><td>40000h</td></tr></tbody></table><p>口诀就是操作系统和字母开头不对付，三英战吕布，刘备一抵二</p><h4 id="显卡映射"><a class="anchor" href="#显卡映射">#</a> 显卡映射</h4><h5 id="1文本映射"><a class="anchor" href="#1文本映射">#</a> 1. 文本映射</h5><p>80 <code>*</code> 25 的文本模式，左上角为 0 点，每两个内存单元为一个字符，第一个字节写入 ASCII 码值，第二个写入前景色和后景色，具体颜色看 30 页吧。高四位背景色，低四位前景色，可以思考先背景后前景。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	mov ax,0B800h</span><br><span class="line">	mov es,axx</span><br><span class="line">	mov di,0</span><br><span class="line">	mov al,&#x27;A&#x27;</span><br><span class="line">	mov ah,71h</span><br><span class="line">	mov cx,2000</span><br><span class="line">again:</span><br><span class="line">	mov es:[di],ax;</span><br><span class="line">	add di,2;</span><br><span class="line">	sub cx,1;</span><br><span class="line">	jnz again</span><br><span class="line">	mov ah,1</span><br><span class="line">	int 21h</span><br><span class="line">	mov ah,4Ch</span><br><span class="line">	int 21h</span><br></pre></td></tr></table></figure><p></p><h5 id="2图形映射"><a class="anchor" href="#2图形映射">#</a> 2. 图形映射</h5><p>书上说的是 ax 是 0013h，int 10h 开启的 320 <code>*200</code> 同样左上角开始，每个内存单元为一个字符，一个内存单元用 256 种变化的颜色<br><code>mov ax,0A00h</code><br>mov es,ax<br>mov ax,0013h<br>int 10h<br>恢复文本模式用 mov ax,0003h<br>int 10h</p><h3 id="宽度修饰"><a class="anchor" href="#宽度修饰">#</a> 宽度修饰</h3><p>其实就是指针，有:</p><ul><li>byte ptr</li><li>word ptr</li><li>dword ptr<br>这些都是用来修饰变量的<br>以下两种情况不用加宽度修饰:</li><li>指令中的变量有变量名不需要加宽度修饰</li><li>指令中的另一个操作数有明确宽度<br>就是事先用 db 什么的定义过了<br>inc dword ptr ds: <code>[si]</code></li></ul><h3 id="变量引用"><a class="anchor" href="#变量引用">#</a> 变量引用</h3><p>其实就是没有 iterator，导致数组每个不同步长要自己计算 就是 dword 要用 + 4 来走</p><h3 id="寄存器"><a class="anchor" href="#寄存器">#</a> 寄存器</h3><p>8086 有 14 个寄存器:ax,bx,cx,dx,sp,bp,si,di,cs,ds,es,ss,ip,fl, 均为 16 位<br>80836 除了段寄存器 cs，ds,es,ss 其他都加前缀 e 升级为 32 位<br>fl 是标志寄存器，IP,SP 也可以用来偏移地址，不过你用不了就是了<br><strong>CS 不能用 mov 指令赋值，只能用 jmp far ptr、jmp dword ptr、call far<br>ptr 这类间接改变，ds、es、ss 可以用 mov 赋值，但源操作数只能是寄存器或变量，注意有变量，同时寄存器只能是 x 四大傻和 sp、bp、si、di</strong><br>dos 在把控制权交给 exe 前，会对以下寄存器赋值:<br>cs = 代码段的段地址<br>IP = 首条指令偏移地址<br>SS = 堆栈段的段地址<br>SP = 堆栈段的长度<br>DS=PSP 段址<br>ES=PSP 段址<br>SS:SP 指向堆栈顶，PSP 是程序段前缀，是 dos 分配给 EXE，位于首段前的 100h 字节的内存块，存储了某些命令行参数，DS 不是数据段段地址，因而开始运行得先用 ax 赋值<br>#可能没看<br>实际能放在【】就那四个，sp 和 ip 动不了</p><h3 id="标志寄存器"><a class="anchor" href="#标志寄存器">#</a> 标志寄存器</h3><p>FL 是标志寄存器，状态标志有六个：<br>CF,ZF,SF,OF,PF,AF<br>控制标志有三个：<br>DF,IF,TF<br>还剩下七位是保留位，除第一位为 1，其他保留位都为 0</p><ul><li>CF 受 add,sub,mul,imul 和移位影响，进位和借位 CF 置 1，与此有关指令 jc，jnc,clc (将 cf 清零 clear carry),stc (set carry),cmc (compelment 反转 carry) adc 带进位加就是结果多加个 CF</li><li>ZF 受算术逻辑和移位影响，结果为 0 时，ZF=0，与其有关的指令为 jz 和 je 和 jnz 和 jne（等价）</li><li>SF 取运算结果最高位，也就是结果为负之类的，有关的时 js 和 jns</li><li>OF 为溢出标志，正数相加为负数负数相加为正数还有乘积大于被乘数宽度这类的 OF=1，当移动一位后最高位不同了为 1，感觉时强化版的 CF。有 jo 和 jno</li><li>PF，奇偶校验位，偶数为 1，jp 和 jnp 和 jpe（parity even 的意思）和 jpo（parity odd 的意思）</li><li>AF，辅助进位，加减法时第三位向第四位借位或进位置 1，与 BCD 有关<br>控制标志</li><li>IF 禁止硬件中断，IF=0 禁止，cli（clear interrupt），sti</li><li>TF（Trap flag），位于第八位，设置 CPU 运行模式，TF=1 为单步模式，每一条指令后会跟 int 01h ；另一个是常规模式，只能通过<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">or ax,100h</span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><br>来设置，不能用单条指令设置</li></ul><h3 id="端口"><a class="anchor" href="#端口">#</a> 端口</h3><p>CPU 不能直接控制 I/O 设备，必须要向相关端口发送信号才能输出控制信号到端口，也必须读取信号才能获取信息。<br>端口地址独立于内存地址，仅有 16 位偏移地址， <code>[0000h,0FFFFh]</code> , 读写指令为 in,out 如 in al,61h,out 21h,al 一个是读入一个是输出</p><h2 id="汇编语言源程序格式"><a class="anchor" href="#汇编语言源程序格式">#</a> 汇编语言源程序格式</h2><h3 id="三类语句"><a class="anchor" href="#三类语句">#</a> 三类语句</h3><ul><li>指令语句</li><li>伪指令语句</li><li>汇编指示语句<br>伪指令定义数组或变量，数组名变量名以及类型在编译后都会消失，main, 这种函数和标号是这个伪指令<br>指示语句告诉编译器如何编译程序 segment 之类的还有 assume 还有.386 还有 end main 都是指示语句</li></ul><h3 id="段的定义-假设与引用"><a class="anchor" href="#段的定义-假设与引用">#</a> 段的定义、假设与引用</h3><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segmentname segement   [use] [align] [combine] [&#x27;class&#x27;]</span><br><span class="line"> statements</span><br><span class="line">segmentname ends</span><br></pre></td></tr></table></figure><br>段定义开始和结束应一致，段名与变量名数组名和标号名规范一致：不能以数字开头，可以有三个特殊字符、英文字母、数字和下划线，具体看 53 页<p></p><ul><li>use 表示偏移地址宽度，use32 表示偏移地址为 32 位宽度。开头有.386 则默认 use32.</li><li>align 表示对齐方式，可以为 byte word dword para page 这五个关键字，para 是 16 字节，页是 256 字节貌似是平方 emmm，省略的话默认 para，对齐方式是指段首地址能被这个 align 整除，如果不行就会对前一个段补 00h。如果 align 不为 para 可能造成首字节偏移地址不为 0, 此时 align 为 byte，且这个段和上个段首地址相同</li><li>’class‘表示类别名可变且须以单引号括起来，这个表示 link 是在 exe 文件中重排顺序以达到邻近。</li><li>combine 可能为 public 和 stack 用于代码和数据段定义，段名相同类别名相同合并类型为 public 的连接时会合成一个段。而类型为 stack 的会合并为一个堆栈段，ss 指向段头，sp 表示长度，如果不存在同名就可以省去 public。但堆栈段不能省区 stack，否则会被当作普通数据段，ss 会初始化为首段，sp 为 0</li></ul><h4 id="段定义的简化格式"><a class="anchor" href="#段定义的简化格式">#</a> 段定义的简化格式</h4><p>其实就是少了 <code>[]</code> 内容然后堆栈段还是有 stack，一般是 db 400h dup (0),dw 200h dup (0)<br>第二个是重复个数，dup 是 duplicate（重复）的意思，里面初始化为 0</p><h4 id="段的假设"><a class="anchor" href="#段的假设">#</a> 段的假设</h4><p>就是 assume segreg:segmentname segreg 就是段寄存器，后面的是段名。这句话并不是赋值作用，而是帮助编译源程序时将对应变量和标号段地址替换成关联寄存器。就是把 data 换成 ds，code 换成 cs。</p><h4 id="段的引用"><a class="anchor" href="#段的引用">#</a> 段的引用</h4><p>可以用两种形式：</p><ul><li>段名</li><li>seg 变量名或标号名（成员的父亲嘛）</li></ul><h3 id="程序的结束"><a class="anchor" href="#程序的结束">#</a> 程序的结束</h3><h4 id="源程序的结束"><a class="anchor" href="#源程序的结束">#</a> 源程序的结束</h4><p>end labelname 指定程序首条指令的位置，IP 会赋值到该偏移地址，CS 会赋值到该标号段地址，如果缺少 labelname IP 等于 0，CS 等于代码段段址，从代码段首条指令开始运行，其实根本找不到代码段</p><h4 id="源程序的终止"><a class="anchor" href="#源程序的终止">#</a> 源程序的终止</h4><p>mov ah,4Ch<br>mov al, 返回码<br>int 21h<br>返回给父程序（调用该程序的本文指 dos 系统），不调用这个终止会继续执行然后死机</p><h3 id="汇编语句的语法成分"><a class="anchor" href="#汇编语句的语法成分">#</a> 汇编语句的语法成分</h3><p>三类语句的格式<br>name mnemonic operand ; comment<br>main:mov ax,data<br>main 是 name mov 是 mnemonic operand 是 ax，data 有点奇怪的 #奇怪</p><ul><li>name 称为名字像，通常指各种名字，大多数语句不用名字项；</li><li>mnemonic 为助记符项目、mov add jmp segment assume end 和 db dw 这些</li><li>operand 成为操作数项目，类型和个数决定于指令，依赖助记符项目</li><li>comment 注释，多行注释用 #（可以换成 % | 这些字符注释内容不能含有标记符）或者 IF 0 ENDIF<br>一行最多一句语句，可用空白符隔开</li></ul><h4 id="常数与常数表达式"><a class="anchor" href="#常数与常数表达式">#</a> 常数与常数表达式</h4><p>整数浮点数和字符常数和字符串常数<br>整数 177Q,11B,0,3Fh Q 表示八进制<br>浮点数 x dd 3.14 float<br>y dq 1.6E-307 double<br>z dt 3.14159E4096 long double<br>字符数 和 py 是一样的，单引号和双引号括起来的都一样 'A' 和 &quot;A&quot; 都一样<br>字符串常数 '' 或 &quot;&quot; 括起来的一串字符，并不包含 00h<br>其实 s db'h','e' 等同于 s db ’he‘</p><h5 id="常数表达式"><a class="anchor" href="#常数表达式">#</a> 常数表达式</h5><p>看下 51 吧，其实就是 +- <code>*</code> / 加上 mod 和 shr 还有 not 还有 offset 还有 seg<br>常量表达式的 xor 之类的与 xor 无关，只是常数表达式的算法，然后负号这些寄存器也没有，同时寄存器一行不能像常数一样写多个表达式</p><h5 id="符号常数"><a class="anchor" href="#符号常数">#</a> 符号常数</h5><p>用符号形式表示的常数，EQU 和 = 可以用来定义<br>symbol equ expression<br>symbol = expression<br>其实就是个 const 变量，不过 = 和 equ 有区别，= 只能是数值或字符类型常数或表达式，同一符号可多次定义，equ 还允许是字符串，甚至汇编语言语句，感觉像宏啊，而且不可以多次定义<br>比如 exitfun equ &lt;mov ah,4Ch&gt;，这个 &lt; 我也不知道为什么，可能是为了表示函数吧，其它表示字符串和常数就不用<br>之后就可以直接写 exitfun</p><h4 id="变量与标号定义及应用"><a class="anchor" href="#变量与标号定义及应用">#</a> 变量与标号定义及应用</h4><p>变量标号取名规则：</p><ul><li>不能数字开头</li><li>$ 与？不能单独作为变量名或标号名</li><li>包含字符最多 31</li><li>缺省情况下，变量名及标号名不区分大小写（可通过 masm /Ml 源程序名 来强制区分）</li><li>不能重复定义</li><li>不能与指令名、伪指令名、汇编指示指令名相同</li></ul><h5 id="变量定义"><a class="anchor" href="#变量定义">#</a> 变量定义</h5><p>变量名 db|dw|dd|dq|dt 初始值<br>可以用 dup 初始化相同值<br><code>abc db 100 dup(0)</code> dup 表示重复，100 表示重复次数，而非数组大小<br>dup 允许嵌套，如： <code>y db 2 dup('a',3 dup('B'),'C')</code></p><h5 id="标号定义"><a class="anchor" href="#标号定义">#</a> 标号定义</h5><p>其实就是 labelname:, 可以被 call 被 jmp 被 loop，我们也可以用伪指令 label 来定义标号<br><code>labelname label near|far|byte|word|dword|qword|tbyte</code><br>near|far 这些都是标号类型，表示近标号，远标号，字节，字，双字，四字，十字节，牵连个是标号类型，后 5 个是变量类型<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc label byte ;</span><br><span class="line">db 1,3,4;其实就是abc db 1,3,4</span><br><span class="line">far_away label far ;</span><br><span class="line">  ....//这个就是函数</span><br></pre></td></tr></table></figure><br>这个 label byte 后面可以不跟初始值，相当于声明这个变量但不分配内存空间，abc 就是接下来数组名字或者数组就是初始值，其实就是 abc 就是那一块地址，没有内容，不占空间，这样子可以出现定义多种类型变量，就像 union<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a label byte</span><br><span class="line">b label word</span><br><span class="line">db 12h,34h</span><br></pre></td></tr></table></figure><br>由于小端规则，所以 b 为 3412h。<br>近标号转换为仅有偏移地址，远标号转换为带段地址和偏移地址。<br>对应短跳和远眺，短跳指令 3 字节，远跳指令 5 字节，这个分类取决于 jmp 起点和目标是否在同一个段。指令中加入 far ptr 和 near ptr 属于强制转换。跳向不在同段的 label near 要在指令中加入 far ptr ，向前引用不在同一段的（源程序当前代码下方）label far ptr 也要在指令中加入 far ptr，比 c 烦。<p></p><h5 id="变量引用-2"><a class="anchor" href="#变量引用-2">#</a> 变量引用</h5><p>在数据段，var 和 offset var 可以表示 dw 操作数下 var 的近地址，var 还可以作为 dd 操作数下 var 的远地址，在代码段只能用 offset var 表示偏移地址，但在数据段可以表示近指针，远指针。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xyz db &#x27;w&#x27;</span><br><span class="line">addr1 dw offset xyz</span><br><span class="line">addr3 dd xyz</span><br></pre></td></tr></table></figure><br>这个 dd 属性要想赋值给两个 16 位寄存器得用 word ptr 强制转换<p></p><h3 id="位置计数器"><a class="anchor" href="#位置计数器">#</a> 位置计数器</h3><p>编译器会用位置计数器的变量来记录段内变量和标号偏移地址，段定义开始自动清零，每条指令后宽度会加到位置计数器里，$ 可以得到当前位置计数器的值，我怀疑这个就是你的位置编号。其实就是当前位置的偏移地址详细看 58 页</p><h2 id="调试"><a class="anchor" href="#调试">#</a> 调试</h2><p>全球唯一能调试保护模式用户程序的调试器 - Bochs Enhanced Debugger, 本身相当于一个虚拟的，</p><h3 id="软件断点"><a class="anchor" href="#软件断点">#</a> 软件断点</h3><p>通过改写指令首字节为 0CCh 设置的指令执行断点，对应 int3h, 使调试器获得控制权。<br>单步执行会在指令执行后调用 int 1h，int 1h 会接着改写首字节为 0CCh，</p><h3 id="硬件断点"><a class="anchor" href="#硬件断点">#</a> 硬件断点</h3><p>是通过把指令首字节地址、变量地址写入调试器寄存器而设置的指令执行断点或变量执行断点，由于 CPU 能保存断点地址寄存器只有 4 个，所以硬件断点的数量最多只有 4 个，硬件断点只会监控而不改变值，所以容易找出数组越界这类问题。S-ICE 支持四个硬件断点，Bochs 支持功能上类似的 16 个指令执行断点和 16 个变量读写断点</p><h3 id="debug调试程序"><a class="anchor" href="#debug调试程序">#</a> debug 调试程序</h3><p>p64 和 65 和 p67 和 68-69，因为上课只讲了 td<br>tasm 和 tlink 可以看到源码但 masm 和 link 就不行<br>可以改变指令，也可以改变数据，但是字母开头前缀要加 0，二进制 B 后缀，十进制 D 后缀。</p><h2 id="指令系统"><a class="anchor" href="#指令系统">#</a> 指令系统</h2><h3 id="指令结构"><a class="anchor" href="#指令结构">#</a> 指令结构</h3><p>指令 = 操作码 + 操作数<br>0-2 个操作数，分别叫元操作数指令，单操作数指令，双操作数指令<br>操作数有常数，寄存器，变量</p><h4 id="数据传输指令"><a class="anchor" href="#数据传输指令">#</a> 数据传输指令</h4><p>mov dest,src</p><ul><li>不影响标志位</li><li>dest,src 不能全为内存变量</li><li>等宽原则</li><li>常数或段寄存器不能赋值给段寄存器</li><li>不能对 cs，IP,FL 赋值<br>push op<br>会自动判断大小的，然后移动 bp 指针</li><li>不能移动 8 位宽度操作数和常数</li><li>不影响标志位<br>pop op<br>同 push 一样<br>xchg op1，op2</li><li>不能有段寄存器，不影响标志位，同时不能两个 memory 互相操作</li></ul><h4 id="输入输出指令"><a class="anchor" href="#输入输出指令">#</a> 输入输出指令</h4><p>in al,port</p><ul><li>当 port&gt;0FFh 后，只能使用 in al,dx 格式，不能使用常数了，&lt;= 都可以，这个怎么和 80836 的 shl 差不多<br>out port,al</li><li>与 in 一致</li></ul><h4 id="地址传输命令"><a class="anchor" href="#地址传输命令">#</a> 地址传输命令</h4><ol><li>lea dest,src<br>lea reg,mem；load effective address<br>就是取 src 的地址给 dest</li><li>lds dest,src 取出远指针，段地址给 ds，偏移地址给 dest<br><code>lds si,es:[di]</code></li><li>les dest ,src 就是 ds 换成了 es，多为 les di</li></ol><h4 id="标志寄存器传送指令"><a class="anchor" href="#标志寄存器传送指令">#</a> 标志寄存器传送指令</h4><p>这些指令都是对 FL 操作<br><strong>lahf</strong><br>把 fl 低 8 位给 ah，为啥低给高 8 位我也不清楚<br>load AH with flags<br><strong>sahf</strong><br>把 ah 赋值给 fl 的低八位<br>store AH in flags<br><strong>pushf</strong><br>就是 push fl，但是 push 不能用来操作 fl<br><strong>popf</strong><br>一样的<br><strong>pushfd</strong><br>把 EFLpush 进去<br><strong>popfd</strong></p><h4 id="转换指令"><a class="anchor" href="#转换指令">#</a> 转换指令</h4><p><strong>cbw</strong>(Convert Byte to Word)<br>把 al 符号扩充到 ax<br><strong>cwd</strong>(Convert word to double word)<br>ax 扩充到 dx:ax 中，：表示连接符，这个扩充到 dx 是因为一开始的 x86 没有 32 位<br><strong>cdq</strong>(Convert double word to quadruple word)<br><strong>movsx dest,src</strong>（move by sign extension）(只能扩充到 16 位和 32 位寄存器，src 可以是 mem8 和 mem16)<br>把 src 符号扩充到 dest，src 可包含内存变量，但是位数偏低，可能要 ptr<br><strong>movzx dest,src</strong> ( move by zero extension)<br>一样的格式，只不过零扩充</p><h4 id="换码指令"><a class="anchor" href="#换码指令">#</a> 换码指令</h4><p><strong>xlat</strong><br>把 byte ptr ds: <code>[bx+AL]</code> 赋值给 AL<br>含义 translate 确实没懂啊</p><h4 id="加法指令"><a class="anchor" href="#加法指令">#</a> 加法指令</h4><p>__add dest,src__影响 CF<br><strong>inc op</strong><br>不影响 CF<br><strong>adc dest,src</strong><br>带进位加 add with carry</p><h4 id="减法指令"><a class="anchor" href="#减法指令">#</a> 减法指令</h4><p><strong>sub</strong><br><strong>sbb</strong><br>带借位减，dest-src-CF<br>subtract with borrow 用于 ds：ax 中 ax 借位后操作 ds<br><strong>dec</strong><br>不影响 CF<br><strong>neg</strong><br>计算 op 相反数<br><strong>cmp op1,op2</strong><br>没想到吧，比较也在这，不保存差值，但会影响状态标志</p><h4 id="jcc跳转指令"><a class="anchor" href="#jcc跳转指令">#</a> JCC 跳转指令</h4><p><code>ja</code> <code>jae</code> jump above （or equal) CF <code>==0</code> 且 ZF <code>==0</code> 无借位且不等，注意只写了 ja<br><code>jb jbe</code> jump below CF <code>==1</code> || ZF <code>==1</code> 有借位或相等，注意只写 jbe<br><code>je jne</code> ZF<br><code>jg</code> jump if greater 这个是有符号大于 <code>SF==OF&amp;&amp; ZF==0</code><br><code>jge</code> <code>SF==OF</code><br><code>jl jle</code> 有符号小于</p><h4 id="乘法指令"><a class="anchor" href="#乘法指令">#</a> 乘法指令</h4><p><strong>mul src</strong> 非符号乘法<br>imul src 带符号乘法 signed mul<br>div src 除数为 0 或商无法保留会出现触发溢出，此时 CPU 会在除法指令上方插入一条 00H 指令<br>idiv op //signed divide</p><h3 id="浮点运算指令"><a class="anchor" href="#浮点运算指令">#</a> 浮点运算指令</h3><p>fadd,fsub,fmul,fdiv,fild,fld,fst,fstp，不接受寄存器</p><h3 id="8个小数寄存器"><a class="anchor" href="#8个小数寄存器">#</a> 8 个小数寄存器</h3><p>st(0),st(1),st(2),st(3),st(4),st(5),st(6),st(7)<br>这 8 个宽度都是 80 位，<br>8 个小数寄存器构成一个 FPU 堆栈，堆栈顶端小数寄存器物理编号记作 TOP，顶端逻辑编号恒为 0，st (i) 中 i 为逻辑编号。物理编号 p：p=(TOP+i)%8, 具体看 p100<br>st (0) 可以简写为 st<br>fld 和 fild 会装入 FPU 堆栈里，这个就是使用一次堆栈顶物理编号 - 1module8,fstp 会弹出，此时是 + 1<br>TD 中在 view-&gt;Numeric processor 可以在代码窗下方查看 8 个小数寄存器</p><h3 id="十进制调整指令"><a class="anchor" href="#十进制调整指令">#</a> 十进制调整指令</h3><p>BCD（Binary Coded Decimal) 指用二进制编码表示十进制数。分为压缩 BCD 和非压缩 BCD，压缩使用 4 个二进制位表示一个十进制，非压缩使用 8 个。<br>如十进制 37 用 37h 和 0307h 的区别。</p><h4 id="压缩bcd调整指令"><a class="anchor" href="#压缩bcd调整指令">#</a> 压缩 BCD 调整指令</h4><p><code>daa</code> 用来将 AL 表示为十进制<br>这个换算有点离谱，建议看看 p102-105，如第一位大于等于 A，那么加 6，第二位大于等于 A，第二位加 60h<br>daa 是将两个 BCD 的十六进制加法出来的 al 转换为十进制<br>das 把加变成减，也就是减法调整<br>#可以试试能不能直接十六位换成十进制</p><h3 id="非压缩bcd指令"><a class="anchor" href="#非压缩bcd指令">#</a> 非压缩 BCD 指令</h3><p>aaa，AH+1,AL+6（ASCII adjust after addition<br>aas 减法调整，把 + 变成 -<br>aam 乘法调整 AH=AL/10 AL=AL%10<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul bl</span><br><span class="line">aam</span><br></pre></td></tr></table></figure><br>aad 除法<br>AH=0,AL=(AH <code>*</code> 10+AL)&amp; 0FFh；<br># 有点离谱<p></p><h3 id="逻辑运算指令和移位指令"><a class="anchor" href="#逻辑运算指令和移位指令">#</a> 逻辑运算指令和移位指令</h3><p>and mem，reg || and reg，idata||and mem，idata 不能 mem 比 mem<br>or<br>xor<br>not 取反，单元 not reg<br>test 不记录结果但会影响状态标志的 and 指令</p><h2 id="字符串操作"><a class="anchor" href="#字符串操作">#</a> 字符串操作</h2><p>目标都是 es：di<br>movs (字符串复制) movsb ,movsw,movsd (从 ds 复制到 es)<br>cmps（字符串比较）<br>scas（搜索字符串）scas 搜索 al，ax，eax 的值<br>stos（写入字符串）<br>lods（读取字符串）<br>rep（重复）<br>repe（相等重复）<br>repz<br>repne<br>repnz<br>repe=repz<br>顺序复制字符串<br>ds：si<br>es：di 调好值<br>然后 cx=slen<br>cld# 把 DF 清 0，正方向<br>rep movsb di+=1<br>rep movsw di+=2<br>rep movsd 复制字符串<br>repe cmpsb<br>repne cmpsb 比较两个</p><p>repescasb<br>scasw 扫描 es:di</p><p>stosw<br>al，ax，eax 写入字符串 es：di 指向字符串</p><p>lodsb 将 ds：【si】写入 al</p><h3 id="控制转移指令"><a class="anchor" href="#控制转移指令">#</a> 控制转移指令</h3><p>jmp 分为三类：<br>短跳（short jump）跳转指令用一个字节表示<br>近跳（near jump）跳转距离或目标地址用一个字表示<br>远眺（far jump）目标地址用 1 个远指针表示</p><h4 id="短跳"><a class="anchor" href="#短跳">#</a> 短跳</h4><p>0EBh，idata8<br>机器码 0EBh，<br>跳转距离是目标地址和下条指令偏移地址之差<br>距离为 <code>[-128,127]</code><br>idata = 标号 -(当前偏移地址 + 2)</p><h4 id="近跳"><a class="anchor" href="#近跳">#</a> 近跳</h4><p>0E9h，idata16L8，idataH8<br>idata = 标号 -（$+3)<br>近跳也可以写成 <strong>jmp reg16</strong> <strong>jmp mem16</strong></p><h4 id="远跳"><a class="anchor" href="#远跳">#</a> 远跳</h4><p>0EAh，idata32L16,....<br>操作：IP=idata32L16<br>CS=idata32H16<br><strong>jmp far ptr 标号</strong>，只能跳到标号，要做到指定位置，只能用机器码实现，参考 p134.<br><strong>jmp mem32</strong></p><h3 id="条件跳转"><a class="anchor" href="#条件跳转">#</a> 条件跳转</h3><p>参考 p135-136<br>有个 <strong>jcxz</strong> jump if cx is zero<br>jecxz 不知道为啥有这个</p><h3 id="循环"><a class="anchor" href="#循环">#</a> 循环</h3><p><strong>loop 标号</strong>，根据 cx 值操作，但是 cx-- 在前面，才比较 cx <code>==0</code> , 也许这就是 jcxz 的作用，来在 loop 前表示 0 的情况跳出<br><strong>loopz 标号</strong> 同时会检测 ZF 是否为 0，如果不为 0 也结束，可以用 test bx，ax 来操作 ZF<br><strong>loopnz 标号</strong></p><h3 id="调用与返回"><a class="anchor" href="#调用与返回">#</a> 调用与返回</h3><h4 id="call-near-ptr-dest"><a class="anchor" href="#call-near-ptr-dest">#</a> call near ptr dest</h4><p>0E8h,idata16L8,idata16H8<br>此时 SP=SP-2 来保存这个下一个地址<br><strong>call near ptr 标号</strong>，idata16 = 标号 -（$+3)<br><strong>call reg16</strong> <strong>call mem16</strong> 这两个也是一样的</p><h4 id="retn-retn-idata16"><a class="anchor" href="#retn-retn-idata16">#</a> retn /retn idata16</h4><p><strong>retn</strong> back_addr= word ptr ss: <code>[sp]</code> SP=SP+2 IP=back_addr<br><strong>retn idata16</strong> SP=SP+2+idata16 其他没区别<br>代码看 p141</p><blockquote><p>注意：在用标号定义的函数及用 <code>函数名 proc ... 函数名 endp</code><br>或 <code>函数名 proc near|far ... 函数名 endp</code> 中，ret 等于 retf，故 retn 不能简写成 ret</p></blockquote><h4 id="call-far-ptr-dest"><a class="anchor" href="#call-far-ptr-dest">#</a> call far ptr dest</h4><p>远调用，目标地址是 dest<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mi>A</mi><mi>h</mi><mtext>，</mtext><mi>i</mi><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>L</mi><mn>16</mn></mrow></msub><mo separator="true">,</mo><mi>i</mi><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>H</mi><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">9Ah，idata_{L16},idata_{H16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord">9</span><span class="mord mathnormal">A</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.08125em">H</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><br>还可以 call mem32<br>idata32 不能是常数，指定常数只能用 5 字节机器码得到<br>retf<br>远返回<br>retf idata16</p><p>需要注意向前调用</p><h3 id="中断指令和中断返回指令-intint-3intoiret"><a class="anchor" href="#中断指令和中断返回指令-intint-3intoiret">#</a> 中断指令和中断返回指令 int,int 3,into,iret</h3><p>int n 调用的目标地址是一个 32 位的远指针，这个远指针被称作 int n 的中断向量保存在 0000:n <code>*</code> 4 处，int 01g 的中断向量是 dword ptr 0: <code>[4]</code> 一共有 100h（256）个中断向量</p><p><strong>int idata8(interrupt)</strong><br>0CDh,idata8<br>old_fl=FL;<br>IF=0<br>TF=0<br>SP=SP-6<br>word ptr SS: <code>[SP]</code> =IP+2<br>SS: <code>[SP+2]</code> =CS<br>SS: <code>[SP+4]</code> =old_fl<br>上面都要加 word ptr</p><p><strong>int 3</strong> 软件断点<br>0CCh<br>ss: <code>[sp]</code> =IP+1</p><p><strong>into</strong> 溢出中断 (interrupt on overflow)<br>0CEh</p><p><strong>iret</strong> 中断返回 (interrupt return)<br>back_ip=ss： <code>[sp]</code><br>back_cs...<br>SP=SP+6；<br>FL=back_fl...<br>就是 int idata8 的返回</p><h2 id="函数定义"><a class="anchor" href="#函数定义">#</a> 函数定义</h2><p>两种形式定义函数:</p><ul><li>用标号定义函数</li><li>用 proc 定义函数<br>标号定义：标号名：<br>retn；也可以写成 ret<br>标号名 label near<br>retn；也可写成 ret<br>标号名 label far<br>retf ；也可以写成 ret<br>proc 定义函数：1.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数名 proc near  #near可简略不写</span><br><span class="line">	...</span><br><span class="line">	retn</span><br><span class="line">函数名 endp</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol></li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数名 proc far...</span><br><span class="line">	retf</span><br><span class="line">函数名 endp</span><br></pre></td></tr></table></figure><p></p><h3 id="传递参数"><a class="anchor" href="#传递参数">#</a> 传递参数</h3><ul><li>寄存器传递参数</li><li>变量传递参数</li><li>堆栈传递参数<br>看 p150 程序。<br>全局变量就是 db 中有个变量<br>变量压入堆栈，不过开头都要 push bp，mov bp，sp，这样才能通过 bp 访问变量和参数，函数参数通过 <code>[bp+idata]</code> 访问，动态变量通过 <code>[bp-idata]</code> 访问（其实就是局部变量）<br>cdecl 采取从右向左参数放入堆栈，pascal 采用从左向右，还有 stdcall 详情看 p153-156</li></ul><blockquote><p>动态变量通过初始化框架后 (push bp、mov bp,sp) 后在 sub bp,idata, 此时可通过 <code>[bp-idata]</code> 来访问了。</p></blockquote><h2 id="中断程序设计"><a class="anchor" href="#中断程序设计">#</a> 中断程序设计</h2><p>首先 cmp 之后接 jmp 指令会在中间产生 int 8h 的中断，具体看 p161<br># 具体为什么问问钟神<br>程序得看看 p160<br>还有键盘中断 p166<br>解密指令 p168</p><h3 id="驻留程序设计"><a class="anchor" href="#驻留程序设计">#</a> 驻留程序设计</h3><p>如果我们希望一个程序的中断向量影响像一个程序，不应该使用 int 21h 的 4Ch 号功能，而应该使用 int 21h 的 31h 号功能（Terminate &amp;Stay Resident,TSR),<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AH=31h</span><br><span class="line">AL=返回码</span><br><span class="line">DX=从PSP起需要保留的内存块的节长度</span><br></pre></td></tr></table></figure><br>节长度 para 是 10 字节 / 节。p171 页教你开挂<p></p><h2 id="文件操作"><a class="anchor" href="#文件操作">#</a> 文件操作</h2><p>与内存相关的 dos 中断调用</p><h3 id="内存分配"><a class="anchor" href="#内存分配">#</a> 内存分配</h3><table><thead><tr><th>功能号</th><th>功能</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>48h</td><td>分配内存</td><td>AH=48H;BX = 待分配内存块的节长度</td><td>成功时 ax 为段地址，CF=0，失败时 CF=1</td></tr><tr><td>49h</td><td>释放内存</td><td>AH=49h，ES = 待释放内存块的段地址</td><td>成功时 CF=0，失败时 CF=1</td></tr><tr><td>4Ah</td><td>重分配内存</td><td>BX = 节长度</td><td></td></tr></tbody></table><p>与文件操作相关</p><table><thead><tr><th>功能号</th><th>功能</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>3Ch</td><td>创建文件</td><td>CX = 文件属性；DS:DX-&gt; 文件名</td><td>成功 ax 返回 handle，CF=0, 失败 ax 为错误码，CF=1</td></tr><tr><td>3Dh</td><td>打开文件</td><td>AL 为打开方式</td><td></td></tr><tr><td>3Eh</td><td>关闭文件</td><td>BX=handle</td><td></td></tr><tr><td>3Fh</td><td>读文件</td><td>CX: 待读字节数</td><td>成功时，AX 为已读字节数；失败 ax 为错误码‘’</td></tr><tr><td>40H</td><td>写文件</td><td></td><td></td></tr><tr><td>42h 移动文件指针</td><td></td><td></td><td></td></tr></tbody></table><h2 id="混合语言编程"><a class="anchor" href="#混合语言编程">#</a> 混合语言编程</h2><p>tcc 编译<br>int x=10;<br>c 语言中可含有 asm mov ax, <code>[x]</code> ;<br><code>__</code> declspec(naked) int f(int a,int b){<br><code>__</code> asm{<br>push ebp<br>...<br>}<br>}<br>int main(){</p><p>}<br>感觉不好写，直接看 p180-181 吧；<br>主要段名注意是_TEXT segment byte public 'CODE'<br>然后要恢复 bx，bp，si，di<br>tcc -v caller.c caller.obj</p><h2 id="int-h"><a class="anchor" href="#int-h">#</a> int ...h</h2><p>首先 mov ah,2<br>int 21h 是输出 dl 的字符<br>mov ah,9<br>int 21h 是输出 ds：dx 指向的以 '$' 结尾的字符串</p><div class="tags"><a href="/tags/%E7%AC%94%E8%80%85%E6%98%AF%E8%8F%9C%E9%B8%9F%EF%BC%8C%E4%B8%8A%E8%AF%BE%E4%B8%8D%E8%AE%B0%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9B%A0%E8%80%8C%E5%8F%AA%E6%9C%89%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0%E4%BA%86/" rel="tag"><i class="ic i-tag"></i> 笔者是菜鸟，上课不记笔记，因而只有补天笔记了</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-01-25 20:05:51" itemprop="dateModified" datetime="2025-01-25T20:05:51+08:00">2025-01-25</time> </span><span id="2025/01/25/less/x86/x86/" class="item leancloud_visitors" data-flag-title="x86汇编笔记" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="小丑鱼 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="小丑鱼 支付宝"><p>支付宝</p></div><div><img data-src="/imagesnull" alt="小丑鱼 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>小丑鱼 <i class="ic i-at"><em>@</em></i>Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://memoryoffish.github.io/2025/01/25/less/x86/x86/" title="x86汇编笔记">https://memoryoffish.github.io/2025/01/25/less/x86/x86/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/04/28/mips/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tse3-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP-C.8hm3wAHH7SBPAuCF9axnfAHaHa?w&#x3D;216&amp;h&#x3D;216&amp;c&#x3D;7&amp;r&#x3D;0&amp;o&#x3D;5&amp;dpr&#x3D;1.5&amp;pid&#x3D;1.7" title="计原笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>计原笔记</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">期末复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">数制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E4%BD%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">数的位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%89%A9%E5%85%85%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%85%85"><span class="toc-number">1.1.3.</span> <span class="toc-text">零扩充与符号扩充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">字符表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.5.</span> <span class="toc-text">二进制数据计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu-%E5%86%85%E5%AD%98%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">CPU、内存和端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">逻辑地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E5%92%8C%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">直接寻址和间接寻址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%AB%AF%E8%A7%84%E5%88%99"><span class="toc-number">1.2.3.</span> <span class="toc-text">小端规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E6%AE%B5%E5%9D%80%E5%92%8C%E6%AE%B5%E8%A6%86%E7%9B%96"><span class="toc-number">1.2.4.</span> <span class="toc-text">缺省段址和段覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E6%AE%B5%E5%9D%80"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">缺省段址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A6%86%E7%9B%96"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">段覆盖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1m%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E5%92%8C%E6%98%BE%E5%8D%A1%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">1M 内存空间划分和显卡映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%8D%A1%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">显卡映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%96%87%E6%9C%AC%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">1. 文本映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%9B%BE%E5%BD%A2%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">2. 图形映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%BA%A6%E4%BF%AE%E9%A5%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">宽度修饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">变量引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.9.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.10.</span> <span class="toc-text">端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">汇编语言源程序格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">三类语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%89-%E5%81%87%E8%AE%BE%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">段的定义、假设与引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AE%9A%E4%B9%89%E7%9A%84%E7%AE%80%E5%8C%96%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">段定义的简化格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%81%87%E8%AE%BE"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">段的假设</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">段的引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9D%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">程序的结束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9D%9F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">源程序的结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">源程序的终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95%E6%88%90%E5%88%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">汇编语句的语法成分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E4%B8%8E%E5%B8%B8%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">常数与常数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">常数表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%B8%B8%E6%95%B0"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">符号常数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%A0%87%E5%8F%B7%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">变量与标号定义及应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">变量定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">标号定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8-2"><span class="toc-number">1.3.4.2.3.</span> <span class="toc-text">变量引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">位置计数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.4.</span> <span class="toc-text">调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">软件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">硬件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debug%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">debug 调试程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">指令结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">数据传输指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">输入输出指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E4%BC%A0%E8%BE%93%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">地址传输命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">标志寄存器传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">转换指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%A2%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">换码指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.7.</span> <span class="toc-text">加法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.8.</span> <span class="toc-text">减法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jcc%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.9.</span> <span class="toc-text">JCC 跳转指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.10.</span> <span class="toc-text">乘法指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.2.</span> <span class="toc-text">浮点运算指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E4%B8%AA%E5%B0%8F%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">8 个小数寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.4.</span> <span class="toc-text">十进制调整指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9bcd%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">压缩 BCD 调整指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9bcd%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.5.</span> <span class="toc-text">非压缩 BCD 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4%E5%92%8C%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.6.</span> <span class="toc-text">逻辑运算指令和移位指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.</span> <span class="toc-text">字符串操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.1.</span> <span class="toc-text">控制转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%B7%B3"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">短跳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E8%B7%B3"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">近跳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E8%B7%B3"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">远跳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.6.2.</span> <span class="toc-text">条件跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.3.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="toc-number">1.6.4.</span> <span class="toc-text">调用与返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-near-ptr-dest"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">call near ptr dest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#retn-retn-idata16"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">retn &#x2F;retn idata16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-far-ptr-dest"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">call far ptr dest</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4%E5%92%8C%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4-intint-3intoiret"><span class="toc-number">1.6.5.</span> <span class="toc-text">中断指令和中断返回指令 int,int 3,into,iret</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.</span> <span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">传递参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.</span> <span class="toc-text">中断程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">驻留程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.9.1.</span> <span class="toc-text">内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">混合语言编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-h"><span class="toc-number">1.11.</span> <span class="toc-text">int ...h</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2025/01/25/less/x86/x86/" rel="bookmark" title="x86汇编笔记">x86汇编笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="小丑鱼" data-src="/images/avatar.jpg"><p class="name" itemprop="name">小丑鱼</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">2</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">2</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">1</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lbW9yeW9mZmlzaA==" title="https:&#x2F;&#x2F;github.com&#x2F;memoryoffish"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/less/" title="分类于 通识课">通识课</a> <i class="ic i-angle-right"></i> <a href="/categories/less/x86/" title="分类于 汇编">汇编</a></div><span><a href="/2025/01/25/less/x86/x86/" title="x86汇编笔记">x86汇编笔记</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/04/28/mips/" title="计原笔记">计原笔记</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-fish"></i> </span><span class="author" itemprop="copyrightHolder">小丑鱼 @ memory of fish</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">25k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">23 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/01/25/less/x86/x86/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->